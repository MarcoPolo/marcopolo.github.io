<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>MarcoPolo - Partially Functional</title>
    <meta name="viewport" content="width=device-width" />

    <link rel="shortcut icon" href="/favicon.ico" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css" />

    <!-- syntax highlighting CSS -->
    <link type="text/css" rel="stylesheet" href="/css/syntax.css" />
    <link type="text/css" rel="stylesheet" href="/css/zenburn.css" />
    
      <link rel="alternate" type="application/rss+xml" title="RSS" href="https://marcopolo.io/atom.xml">
    
  </head>
  <body>
    <div class="container">
      <div class="site">
        <div class="header">
          <h2 class="title" style="display: inline;"><a href="/">MarcoPolo - <span>Partially Functional</span></a>
          </h2>
        </div>

        
<header>
  <h2>Goodbye, bit rot</h2>
  
  <p class="meta">Feb  1, 2021</p>
</header>

<!-- <div class="postWrapper">
  <div class="leftBumper"></div> -->
<main>
  <aside></aside>
  <article class="post">
    
      
    
    <p>Take a look at this picture:</p>
<p><img src="https://marcopolo.io/code/goodbye-bit-rot/smalltalk-76.png" alt="Smalltalk 76" /></p>
<p>That's a photo of Smalltalk 76 running the prototypical desktop UI. It's
taken for granted that this photo will be viewable for the indefinite future
(or as long as we keep a PNG viewer around). But when we think about code,
maybe the very same Smalltalk code we took this photo of, it's assumed that
eventually that code will stop running. It'll stop working because of a
mysterious force known as <a href="https://en.wikipedia.org/wiki/Software_rot">bit
rot</a>. Why? It's this truly
inevitable? Or can we do better?</p>
<h2 id="we-can-do-better">We can do better</h2>
<p>Bit rot often manifests in the case where some software <em>A</em> relies on a certain
configured environment. Imagine <em>A</em> relies on a shared library <em>B</em>. As time
progresses, the shared library <em>B</em> can (and probably will) be updated
independently of <em>A</em>. Thus breaking <em>A</em>. But what if <em>A</em> could say it
explicitly depends on version <em>X.Y.Z</em> of <em>B</em>, or even better yet, the version
of the library that hashes to the value <code>0xBADCOFFEE</code>. Then you break the
implicit dependency of a correctly configured environment. <em>A</em> stops
depending on the world being in a certain state. Instead, <em>A</em>
<em>explicitly defines</em> what the world it needs should look like.</p>
<h2 id="enter-nix">Enter Nix</h2>
<p>This is what <a href="https://nixos.org/">Nix</a> gives you. A way to explicitly define
what a piece of software needs to build and run. Here's an example of the
definition on how to build the <a href="https://www.gnu.org/software/hello/">GNU
Hello</a> program:</p>
<pre data-lang="nix" class="language-nix "><code class="language-nix" data-lang="nix">with (import &lt;nixpkgs&gt; {});
derivation {
  name = &quot;hello&quot;;
  builder = &quot;${bash}&#x2F;bin&#x2F;bash&quot;;
  args = [ .&#x2F;builder.sh ];
  buildInputs = [ gnutar gzip gnumake gcc binutils-unwrapped coreutils gawk gnused gnugrep ];
  src = .&#x2F;hello-2.10.tar.gz;
  system = builtins.currentSystem;
}
</code></pre>
<p>It's not necessary to explain this <a href="https://nixos.org/guides/nix-pills/generic-builders.html#idm140737320275008">code in
detail</a>.
It's enough to point out that <code>buildInputs</code> defines what the environment should
contain (i.e. it should contain <code>gnutar</code>, <code>gzip</code>, <code>gnumake</code>, etc.). And the
versions of these dependencies are defined by the current version of
<code>&lt;nixpkgs&gt;</code>. These dependencies can be further pinned (or <em>locked</em> in the
terminology of some languages like Javascript and Rust) to ensure that this
program will always be built with the same exact versions of its dependencies.
This extends to the runtime as well. This means you can run two different
programs that each rely on a different <code>glibc</code>. Or to bring it back to our
initial example, software <em>A</em> will always run because it will always use the
same exact shared library <em>B</em>.</p>
<h2 id="a-concrete-example-this-will-never-bit-rot">A concrete example. This will never bit rot.</h2>
<p>To continue our Smalltalk theme, here's a &quot;Hello World&quot; program that, barring a
fundamental change in how Nix Flakes works, will work forever<sup class="footnote-reference"><a href="#1">1</a></sup> on an x86_64
linux machine.</p>
<p>The definition of our program, <code>flake.nix</code></p>
<pre data-lang="nix" class="language-nix "><code class="language-nix" data-lang="nix">{
  inputs.nixpkgs.url = &quot;github:NixOS&#x2F;nixpkgs&#x2F;nixos-20.09&quot;;
  outputs =
    { self, nixpkgs }:
    let
      pkgs = nixpkgs.legacyPackages.x86_64-linux;
    in
    {
      defaultPackage.x86_64-linux = pkgs.writeScriptBin &quot;hello-smalltalk&quot; &#x27;&#x27;
        ${pkgs.gnu-smalltalk}&#x2F;bin&#x2F;gst &lt;&lt;&lt; &quot;Transcript show: &#x27;Hello World!&#x27;.&quot;
      &#x27;&#x27;;
    };
}
</code></pre>
<p>The pinned version of all our dependencies, <code>flake.lock</code></p>
<pre data-lang="json" class="language-json "><code class="language-json" data-lang="json">{
  &quot;nodes&quot;: {
    &quot;nixpkgs&quot;: {
      &quot;locked&quot;: {
        &quot;lastModified&quot;: 1606669556,
        &quot;narHash&quot;: &quot;sha256-9rlqZ5JwnA6nK04vKhV0s5ndepnWL5hpkaTV1b4ASvk=&quot;,
        &quot;owner&quot;: &quot;NixOS&quot;,
        &quot;repo&quot;: &quot;nixpkgs&quot;,
        &quot;rev&quot;: &quot;ae47c79479a086e96e2977c61e538881913c0c08&quot;,
        &quot;type&quot;: &quot;github&quot;
      },
      &quot;original&quot;: {
        &quot;owner&quot;: &quot;NixOS&quot;,
        &quot;ref&quot;: &quot;nixos-20.09&quot;,
        &quot;repo&quot;: &quot;nixpkgs&quot;,
        &quot;type&quot;: &quot;github&quot;
      }
    },
    &quot;root&quot;: {
      &quot;inputs&quot;: {
        &quot;nixpkgs&quot;: &quot;nixpkgs&quot;
      }
    }
  },
  &quot;root&quot;: &quot;root&quot;,
  &quot;version&quot;: 7
}
</code></pre>
<p>copy those files into a directory and run it:</p>
<pre data-lang="bash" class="language-bash "><code class="language-bash" data-lang="bash">‚ùØ nix run
Hello World!
</code></pre>
<h2 id="solid-foundations">Solid Foundations</h2>
<p>With Nix, we can make steady forward progress. Without fear that our foundations
will collapse under us like sand castles. Once we've built something in Nix we
can be pretty sure it will work for our colleague or ourselves in 10 years. Nix
is building a solid foundation that I can no longer live without.</p>
<p>If you haven't used Nix before, here's your call to action:</p>
<ul>
<li>Nix's homepage: <a href="https://nixos.org/">https://nixos.org/</a></li>
<li>Nix's Learning page: <a href="https://nixos.org/learn">https://nixos.org/learn</a></li>
<li>Learn Nix in little bite-sized pills: <a href="https://nixos.org/guides/nix-pills/">https://nixos.org/guides/nix-pills/</a></li>
</ul>
<hr />
<h2 id="disclaimer">Disclaimer</h2>
<p>There are various factors that lead to bit rot. Some are easier to solve than
others. For the purpose of this post I'm only considering programs that are
roughly self contained. For example, if a program relies on hitting a specific
Google endpoint, the only way to use this program would be to emulate the whole
Google stack or rely on that <a href="https://gcemetery.co/">endpoint existing</a>.
Sometimes it's doable to emulate the external API, and sometimes it isn't. This
post is specifically about cases where it is feasible to emulate the external API.</p>
<h3 id="footnotes">Footnotes</h3>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Okay forever is a really long time. And this will likely not run forever. But why? The easy reasons are: &quot;Github is down&quot;, &quot;A source tarball you need can't be fetched from the internet&quot;, &quot;x86_64 processors can't be found or emulated&quot;. But what's a weird reason that this may fail in the future? It'll probably be hard to predict, but maybe something like: SHA256 has been broken and criminals and/or pranksters have published malicious packages that match a certain SHA256. So build tools that rely on a deterministic and hard to break hash algorithm like SHA256 (like what Nix does) will no longer be reliable. That would be a funny future. Send me your weird reasons: <code>&quot;marco+forever&quot; ++ &quot;@marcopolo.io&quot;</code></p>
</div>

  </article>
  <aside></aside>
</main>
  <!-- <div class="leftBumper"></div>
</div> -->


        <div class="footer">
          <div class="contact">
            <div class="std-highlight">
              <pre>
                    <code class="clojure language-clojure" data-lang="clojure">
<span class="p">(</span><span class="k">def </span> <span class="nv">Marco-Munizaga</span>
      <span class="p">{</span><span class="ss">:email</span> <span class="p">(</span><span class="nb">str </span><span class="s">"marco"</span> <span class="s">"@"</span> <span class="s">"marcopolo.io"</span><span class="p">)</span>
       <span class="ss">:github</span> <span class="s"><a href="https://github.com/marcopolo">github.com/marcopolo</a></span>
       <span class="ss">:keybase</span> <span class="s"><a
       href="https://keybase.io/marcopolo">marcopolo</a></span> <span class="p">}</span><span class="p">)</span>
       <span class="ss">:rss</span> <span class="s"><a
       href="https://marcopolo.io/code/goodbye-bit-rot/atom.xml">atom.xml</a></span> <span class="p">}</span><span class="p">)</span>
                    </code>
                  </pre>
            </div>

            <p> </p>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
