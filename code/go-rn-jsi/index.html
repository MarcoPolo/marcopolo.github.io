<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>MarcoPolo - Partially Functional</title>
    <meta name="viewport" content="width=device-width" />

    <link rel="shortcut icon" href="/favicon.ico" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css" />

    <!-- syntax highlighting CSS -->
    <link type="text/css" rel="stylesheet" href="/css/syntax.css" />
    <link type="text/css" rel="stylesheet" href="/css/zenburn.css" />
    
      <link rel="alternate" type="application/rss+xml" title="RSS" href="https://marcopolo.io/atom.xml">
    
  </head>
  <body>
    <div class="container">
      <div class="site">
        <div class="header">
          <h2 class="title" style="display: inline;"><a href="/">MarcoPolo - <span>Partially Functional</span></a>
          </h2>
        </div>

        
<header>
  <h2>Interacting with Go from React Native through JSI</h2>
  
  <p class="meta">Jun 27, 2019</p>
</header>

<!-- <div class="postWrapper">
  <div class="leftBumper"></div> -->
<main>
  <aside></aside>
  <article class="post">
    
    <h1 id="introduction">Introduction</h1>
<p>There are 3 parts that let JS talk to Go:</p>
<ol>
<li>The C++ binding</li>
<li>Installing the binding</li>
<li>Calling Go</li>
</ol>
<p>Not all the code is shown, check out the <a href="https://github.com/MarcoPolo/react-native-hostobject-demo">source code</a> for specifics.</p>
<h3 id="part-1-the-c-binding">Part 1 - The C++ Binding</h3>
<p>The binding is the C++ glue code that will hook up your Go code to the JS runtime. The binding itself is composed of two main parts.</p>
<h4 id="part-1-1-the-c-binding">Part 1.1 - The C++ Binding</h4>
<p>The binding is a c++ class that implements the <code>jsi::HostObject</code> interface. At the very least it's useful for it to have a <code>get</code> method defined. The type of the <code>get</code> method is:</p>
<pre data-lang="c++" class="language-c++ "><code class="language-c++" data-lang="c++">jsi::Value get(jsi::Runtime &amp;runtime, const jsi::PropNameID &amp;name) override;
</code></pre>
<p>It returns a <code>jsi::Value</code> (a value that is safe for JS). It's given the JS runtime and the prop string used by JS when it <code>get</code>s the field. e.g. <code>global.nativeTest.foo</code> will call this method with PropNameID === <code>&quot;foo&quot;</code>.</p>
<h4 id="part-1-2-the-c-binding-s-install">Part 1.2 - The C++ Binding's install</h4>
<p>Now that we've defined our HostObject, we need to install it into the runtime. We use a static member function that we'll call later to set this up. It looks like this:</p>
<pre data-lang="c++" class="language-c++ "><code class="language-c++" data-lang="c++">void TestBinding::install(jsi::Runtime &amp;runtime,
                          std::shared_ptr&lt;TestBinding&gt; testBinding) {
  &#x2F;&#x2F; What is the name that js will use when it reaches for this?
  &#x2F;&#x2F; i.e. `global.nativeTest` in JS
  auto testModuleName = &quot;nativeTest&quot;;
  &#x2F;&#x2F; Create a JS object version of our binding
  auto object = jsi::Object::createFromHostObject(runtime, testBinding);
  &#x2F;&#x2F; set the &quot;nativeTest&quot; propert
  runtime.global().setProperty(runtime, testModuleName, std::move(object));
}
</code></pre>
<h3 id="part-2-installing-the-binding-on-android">Part 2. Installing the binding (on Android)</h3>
<p>Since we have a reference to the runtime in Java land, we'll have to create a JNI method to pass the runtime ptr to the native C++ land. We can add this JNI method to our TestBinding file with a guard.</p>
<pre data-lang="c++" class="language-c++ "><code class="language-c++" data-lang="c++">#if ANDROID
extern &quot;C&quot; {
JNIEXPORT void JNICALL Java_com_testmodule_MainActivity_install(
    JNIEnv *env, jobject thiz, jlong runtimePtr) {
  auto testBinding = std::make_shared&lt;example::TestBinding&gt;();
  jsi::Runtime *runtime = (jsi::Runtime *)runtimePtr;

  example::TestBinding::install(*runtime, testBinding);
}
}
#endif
</code></pre>
<p>Then on the Java side (after we compile this into a shared library), we register this native function and call it when we're ready.</p>
<pre data-lang="java" class="language-java "><code class="language-java" data-lang="java">&#x2F;&#x2F; In MainActivity

public class MainActivity extends ReactActivity implements ReactInstanceManager.ReactInstanceEventListener {
    static {
        &#x2F;&#x2F; Load our jni
        System.loadLibrary(&quot;test_module_jni&quot;);
    }

    &#x2F;&#x2F;... ellided ...

    @Override
    public void onReactContextInitialized(ReactContext context) {
        &#x2F;&#x2F; Call our native function with the runtime pointer
        install(context.getJavaScriptContextHolder().get());
    }

    &#x2F;&#x2F;  declare our native function
    public native void install(long jsContextNativePointer);
}
</code></pre>
<h3 id="part-3-calling-go">Part 3. Calling Go</h3>
<p>Now that our binding is installed in the runtime, we can make it do something useful.</p>
<pre data-lang="c++" class="language-c++ "><code class="language-c++" data-lang="c++">jsi::Value TestBinding::get(jsi::Runtime &amp;runtime,
                            const jsi::PropNameID &amp;name) {
  auto methodName = name.utf8(runtime);

  if (methodName == &quot;runTest&quot;) {
    return jsi::Function::createFromHostFunction(
        runtime, name, 0,
        [](jsi::Runtime &amp;runtime, const jsi::Value &amp;thisValue,
           const jsi::Value *arguments,
           size_t count) -&gt; jsi::Value { return TestNum(); });
  }
  return jsi::Value::undefined();
}

</code></pre>
<p>Here we return a <code>jsi::Function</code> when JS calls <code>global.nativeTest.runTest</code>. When JS calls it (as in <code>global.nativeTest.runTest()</code>) we execute the code inside the closure, which just returns <code>TestNum()</code>. TestNum is a Go function that's exported through cgo so that it is available to c/c++. Our Go code looks like this:</p>
<pre data-lang="go" class="language-go "><code class="language-go" data-lang="go">package main

import &quot;C&quot;

&#x2F;&#x2F; TestNum returns a test number to be used in JSI
&#x2F;&#x2F;export TestNum
func TestNum() int {
	return int(9001)
}
func main() {
}
</code></pre>
<p>cgo builds a header and creates a shared library that is used by our binding.</p>
<h3 id="building">Building</h3>
<ul>
<li>Look at the CMakeLists.txt for specifics on building the C++ code.</li>
<li>Look at from-go/build.sh for specifics on building the go code.</li>
</ul>
<h3 id="a-go-shared-library-for-c-java">A Go Shared Library for C + Java</h3>
<p>It's possible to build the Go code as a shared library for both C and Java, but you'll have to define your own JNI methods. It would be nice if gomobile bind also generated C headers for android, but it doesn't seem possible right now. Instead you'll have to run <code>go build -buildmode=c-shared</code> directly and define your jni methods yourself. Take a look at <code>from-go/build.sh</code> and testnum.go for specifics.</p>
<h2 id="further-reading">Further Reading</h2>
<p><a href="https://medium.com/@christian.falch/https-medium-com-christian-falch-react-native-jsi-challenge-1201a69c8fbf">JSI Challenge #1</a></p>
<p><a href="https://medium.com/@christian.falch/react-native-jsi-challenge-2-56fc4dd91613">JSI Challenge #2</a></p>
<p><a href="http://blog.nparashuram.com/2019/01/react-natives-new-architecture-glossary.html">RN Glossary of Terms</a></p>
<p><a href="https://blog.dogan.io/2015/08/15/java-jni-jnr-go/">GO JNI</a></p>
<p><a href="https://rakyll.org/cross-compilation/">GO Cross Compilation</a></p>

  </article>
  <aside></aside>
</main>
  <!-- <div class="leftBumper"></div>
</div> -->


        <div class="footer">
          <div class="contact">
            <div class="std-highlight">
              <pre>
                    <code class="clojure language-clojure" data-lang="clojure">
<span class="p">(</span><span class="k">def </span> <span class="nv">Marco-Munizaga</span>
      <span class="p">{</span><span class="ss">:email</span> <span class="p">(</span><span class="nb">str </span><span class="s">"marco"</span> <span class="s">"@"</span> <span class="s">"marcopolo.io"</span><span class="p">)</span>
       <span class="ss">:github</span> <span class="s"><a href="https://github.com/marcopolo">github.com/marcopolo</a></span>
       <span class="ss">:keybase</span> <span class="s"><a
       href="https://keybase.io/marcopolo">marcopolo</a></span> <span class="p">}</span><span class="p">)</span>
       <span class="ss">:rss</span> <span class="s"><a
       href="https://marcopolo.io/code/go-rn-jsi/atom.xml">atom.xml</a></span> <span class="p">}</span><span class="p">)</span>
                    </code>
                  </pre>
            </div>

            <p> </p>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
