<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>MarcoPolo - Partially Functional</title>
    <meta name="viewport" content="width=device-width" />

    <link rel="shortcut icon" href="/favicon.ico" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css" />

    <!-- syntax highlighting CSS -->
    <link type="text/css" rel="stylesheet" href="/css/syntax.css" />
    <link type="text/css" rel="stylesheet" href="/css/zenburn.css" />
    
      <link rel="alternate" type="application/rss+xml" title="RSS" href="https://marcopolo.io/atom.xml">
    
  </head>
  <body>
    <div class="container">
      <div class="site">
        <div class="header">
          <h2 class="title" style="display: inline;"><a href="/">MarcoPolo - <span>Partially Functional</span></a>
          </h2>
        </div>

        
<header>
  <h2>From C to Rust to C again. Or: Re-exporting C exports in Rust</h2>
  
  <p class="meta">Dec 12, 2019</p>
</header>

<!-- <div class="postWrapper">
  <div class="leftBumper"></div> -->
<main>
  <aside></aside>
  <article class="post">
    
    <p>The only difference between being a grown up and being a kid, in my experience, is as a grown up, you have much fewer people who are willing to play the game <em>telephone</em> with you. Luckily for me, I have access to a computer, a C compiler, and a Rust compiler. Let me show you how I played telephone with Rust &amp; C.</p>
<p>tl;dr:</p>
<ul>
<li>Rust can't re-export from a linked C library (unless you rename) when compiled as a cdylib.</li>
<li>Look at this <a href="https://github.com/rust-lang/rfcs/issues/2771">issue</a></li>
</ul>
<p>Imagine you have some C code that provides <code>add_two</code>. It looks like this:</p>
<pre data-lang="c" class="language-c "><code class="language-c" data-lang="c">int add_two(int n)
{
    return n + 2;
}
</code></pre>
<p>And you can even let Cargo deal with building your C library by making a build.rs with <code>cc</code>. Like so:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">use cc;

fn main() {
    cc::Build::new().file(&quot;src&#x2F;c&#x2F;foo.c&quot;).compile(&quot;foo&quot;);
}
</code></pre>
<p>Now you want to be able to call <code>add_two</code> from Rust. Easy! You look at the <a href="https://doc.rust-lang.org/nomicon/ffi.html">FFI</a> section in the Nomicon. And follow it like so:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]
#[no_mangle]
extern &quot;C&quot; {
    pub fn add_two(x: u32) -&gt; u32;
}

#[no_mangle]
pub extern &quot;C&quot; fn add_one(x: u32) -&gt; u32 {
    let a = unsafe { add_two(x) };
    a - 1
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn it_works() {
        assert_eq!(add_one(2), 3);
        assert_eq!(unsafe { add_two(2) }, 4);
    }
}
</code></pre>
<p>Now for the last chain in our telephone. We'll make a new C file that will call our Rust defined <code>add_one</code> and our C defined <code>add_two</code>.</p>
<pre data-lang="c" class="language-c "><code class="language-c" data-lang="c">extern int add_one(int n);
extern int add_two(int n);

int main()
{
    return add_one(add_two(39));
}
</code></pre>
<p>We use Clang to build this file:</p>
<pre><code>clang call_rust.c -lrust_c_playground -L.&#x2F;target&#x2F;debug -o call_rust
</code></pre>
<p>Now we have an executable called <code>call_rust</code> which calls a Rust defined function and calls a C defined function that it pulled in from a single Rust Library (called <code>librust_c_playground.dylib</code> on macOS). The flags in the clang command mean: <code>-l</code> link this library; <code>-L</code> look here for the library.</p>
<p>We've built the code, now we can even run it!</p>
<pre><code>.&#x2F;call_rust
echo $? # Print the return code of our program, hopefully 42
</code></pre>
<p>Great! We've called C from a Rust Library from a C program. But there's a catch. This won't work if you are building a <code>cdylib</code>. There isn't an RFC yet on how to re-export C externs. In the mean time you'll either have to: re-export under a different name, or build a <code>dylib</code>. See this issue: <a href="https://github.com/rust-lang/rfcs/issues/2771">Re-exporting C symbols for cdylib</a>.</p>
<p>Hope this helps.</p>

  </article>
  <aside></aside>
</main>
  <!-- <div class="leftBumper"></div>
</div> -->


        <div class="footer">
          <div class="contact">
            <div class="std-highlight">
              <pre>
                    <code class="clojure language-clojure" data-lang="clojure">
<span class="p">(</span><span class="k">def </span> <span class="nv">Marco-Munizaga</span>
      <span class="p">{</span><span class="ss">:email</span> <span class="p">(</span><span class="nb">str </span><span class="s">"marco"</span> <span class="s">"@"</span> <span class="s">"marcopolo.io"</span><span class="p">)</span>
       <span class="ss">:github</span> <span class="s"><a href="https://github.com/marcopolo">github.com/marcopolo</a></span>
       <span class="ss">:keybase</span> <span class="s"><a
       href="https://keybase.io/marcopolo">marcopolo</a></span> <span class="p">}</span><span class="p">)</span>
       <span class="ss">:rss</span> <span class="s"><a
       href="https://marcopolo.io/code/from-c-to-rust-to-c/atom.xml">atom.xml</a></span> <span class="p">}</span><span class="p">)</span>
                    </code>
                  </pre>
            </div>

            <p> </p>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
