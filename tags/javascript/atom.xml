<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>MarcoPolo â€“ Partially Functional - javascript</title>
	<author><name>Marco</name></author>
	<link href="https://marcopolo.io/tags/javascript/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://marcopolo.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2019-09-06T00:00:00+00:00</updated>
	<id>https://marcopolo.io/tags/javascript/atom.xml</id>
	
	<entry xml:lang="en">
		<title>Thoughts on &quot;Why is React doing this?&quot;</title>
		<published>2019-09-06T00:00:00+00:00</published>
		<updated>2019-09-06T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/why-react-response/" type="text/html"/>
		<id>https://marcopolo.io/code/why-react-response/</id>
		<content type="html">&lt;h1 id=&quot;response-to-why-react&quot;&gt;Response to &lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;sebmarkbage&#x2F;a5ef436427437a98408672108df01919&quot;&gt;Why React?&lt;&#x2F;a&gt;&lt;&#x2F;h1&gt;
&lt;p&gt;Some quick thoughts I had after reading the &lt;a href=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;sebmarkbage&#x2F;a5ef436427437a98408672108df01919&quot;&gt;Why React?&lt;&#x2F;a&gt; gist.&lt;&#x2F;p&gt;
&lt;p&gt;Disclaimer: &lt;em&gt;I want to be critical with React. I don&#x27;t disagree that it has done some amazing things&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;compiled-output-results-in-smaller-apps&quot;&gt;&amp;quot;Compiled output results in smaller apps&amp;quot;&lt;&#x2F;h2&gt;
&lt;blockquote&gt;
&lt;p&gt;E.g. Svelte apps start smaller but the compiler output is 3-4x larger per component than the equivalent VDOM approach.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;This may be true currently, but that doesn&#x27;t mean it will always be true of compiled-to frameworks. A theoretical compiler can produce a component that uses a shared library for all components. If a user doesn&#x27;t use all the features of a framework, then a compiler could remove the unused features from the output. Which is something that could not happen with a framework that relies on a full runtime.&lt;&#x2F;p&gt;
&lt;p&gt;Note: I&#x27;m not advocating for a compiled-to approach, I just think this point was misleading&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dom-is-stateful-imperative-so-we-should-embrace-it&quot;&gt;&amp;quot;DOM is stateful&#x2F;imperative, so we should embrace it&amp;quot;&lt;&#x2F;h2&gt;
&lt;p&gt;I agree with OP here. Most use-cases would not benefit from an imperative UI api.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;react-leaks-implementation-details-through-usememo&quot;&gt;&amp;quot;React leaks implementation details through useMemo&amp;quot;&lt;&#x2F;h2&gt;
&lt;p&gt;A common problem to bite new comers is when they pass a closure to a component, and that closure gets changed every time which causes their component to re-render every time. &lt;code&gt;useMemo&lt;&#x2F;code&gt; can fix this issue, but it offloads a bit of work to the developer.&lt;&#x2F;p&gt;
&lt;p&gt;In the above context, it&#x27;s an implementation detail. I&#x27;m not saying it&#x27;s the wrong or right trade off, I&#x27;m only saying that the reason you have to reach for &lt;code&gt;useMemo&lt;&#x2F;code&gt; when passing around closures is because of how React is implemented. So the quote is accurate.&lt;&#x2F;p&gt;
&lt;p&gt;Is that a bad thing? That&#x27;s where it gets more subjective. I think it is, because these types of things happen very often and, in a big app, you quickly succumb to death by a thousand cuts (one closure causing a component to re-render isn&#x27;t a big deal, but when you have hundreds of components with various closures it gets hairy).&lt;&#x2F;p&gt;
&lt;p&gt;The next example OP posts is about setting users in a list.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;js&quot; class=&quot;language-js &quot;&gt;&lt;code class=&quot;language-js&quot; data-lang=&quot;js&quot;&gt;setUsers([
  ...users.filter(user =&amp;gt; user.name !== &amp;quot;Sebastian&amp;quot;),
  { name: &amp;quot;Sebastian&amp;quot; }
]);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you are happy with that syntax, and the tradeoff of having to use &lt;code&gt;key&lt;&#x2F;code&gt; props whenever you display lists, and relying on React&#x27;s heuristics to efficiently update the views corresponding to the list, then React is fine. If, however, you are okay with a different syntax you may be interested in another idea I&#x27;ve seen. The basic idea is you keep track of the diffs themselves instead of the old version vs. the new version. Knowing the diffs directly let you know exactly how to update the views directly so you don&#x27;t have to rely on the &lt;code&gt;key&lt;&#x2F;code&gt; prop, heuristics, and you can efficiently&#x2F;quickly update the View list. This is similar to how &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;immerjs&#x2F;immer&quot;&gt;Immer&lt;&#x2F;a&gt; works. &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;futures-signals&#x2F;0.3.8&#x2F;futures_signals&#x2F;tutorial&#x2F;index.html&quot;&gt;Futures Signals&lt;&#x2F;a&gt; also does this to efficiently send updates of a list to consumers (look at &lt;code&gt;SignalVec&lt;&#x2F;code&gt;).&lt;&#x2F;p&gt;
&lt;h2 id=&quot;stale-closures-in-hooks-are-confusing&quot;&gt;&amp;quot;Stale closures in Hooks are confusing&amp;quot;&lt;&#x2F;h2&gt;
&lt;p&gt;I agree with OP&#x27;s points here. It&#x27;s important to know where your data is coming from. In the old hook-less style of React, your data was what you got from your props&#x2F;state and nothing else. With hooks, it&#x27;s easier to work with stale data that comes in from outside your props. It&#x27;s a learning curve, but not necessarily bad.&lt;&#x2F;p&gt;
&lt;p&gt;One thing I find interesting is that the use of hooks moves functional components into becoming more stateful components. I think this is fine, but it loses the pure functional guarantees you had before.&lt;&#x2F;p&gt;
&lt;p&gt;I haven&#x27;t yet made up my mind about hooks that interact with the context. (i.e. &lt;code&gt;useSelector&lt;&#x2F;code&gt; or &lt;code&gt;useDispatch&lt;&#x2F;code&gt;) since the context is less structured. i.e. This component&#x27;s selector function for &lt;code&gt;useSelector&lt;&#x2F;code&gt; relies on the state being &lt;code&gt;X&lt;&#x2F;code&gt;, but &lt;code&gt;X&lt;&#x2F;code&gt; isn&#x27;t passed in, it&#x27;s set as the store in redux configuration file somewhere else. Now that the component relies on the shape of the store being &lt;code&gt;X&lt;&#x2F;code&gt; it makes it harder to move out. This may not actually matter in practice, and it may be much more useful to be able to pull arbitrary things out of your store. Hence why I&#x27;m currently undecided about it.&lt;&#x2F;p&gt;
</content>
	</entry>
	
	<entry xml:lang="en">
		<title>Interacting with Go from React Native through JSI</title>
		<published>2019-06-27T00:00:00+00:00</published>
		<updated>2019-06-27T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/go-rn-jsi/" type="text/html"/>
		<id>https://marcopolo.io/code/go-rn-jsi/</id>
		<content type="html">&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;&#x2F;h1&gt;
&lt;p&gt;There are 3 parts that let JS talk to Go:&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;The C++ binding&lt;&#x2F;li&gt;
&lt;li&gt;Installing the binding&lt;&#x2F;li&gt;
&lt;li&gt;Calling Go&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Not all the code is shown, check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;react-native-hostobject-demo&quot;&gt;source code&lt;&#x2F;a&gt; for specifics.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;part-1-the-c-binding&quot;&gt;Part 1 - The C++ Binding&lt;&#x2F;h3&gt;
&lt;p&gt;The binding is the C++ glue code that will hook up your Go code to the JS runtime. The binding itself is composed of two main parts.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;part-1-1-the-c-binding&quot;&gt;Part 1.1 - The C++ Binding&lt;&#x2F;h4&gt;
&lt;p&gt;The binding is a c++ class that implements the &lt;code&gt;jsi::HostObject&lt;&#x2F;code&gt; interface. At the very least it&#x27;s useful for it to have a &lt;code&gt;get&lt;&#x2F;code&gt; method defined. The type of the &lt;code&gt;get&lt;&#x2F;code&gt; method is:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;jsi::Value get(jsi::Runtime &amp;amp;runtime, const jsi::PropNameID &amp;amp;name) override;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;It returns a &lt;code&gt;jsi::Value&lt;&#x2F;code&gt; (a value that is safe for JS). It&#x27;s given the JS runtime and the prop string used by JS when it &lt;code&gt;get&lt;&#x2F;code&gt;s the field. e.g. &lt;code&gt;global.nativeTest.foo&lt;&#x2F;code&gt; will call this method with PropNameID === &lt;code&gt;&amp;quot;foo&amp;quot;&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;part-1-2-the-c-binding-s-install&quot;&gt;Part 1.2 - The C++ Binding&#x27;s install&lt;&#x2F;h4&gt;
&lt;p&gt;Now that we&#x27;ve defined our HostObject, we need to install it into the runtime. We use a static member function that we&#x27;ll call later to set this up. It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;void TestBinding::install(jsi::Runtime &amp;amp;runtime,
                          std::shared_ptr&amp;lt;TestBinding&amp;gt; testBinding) {
  &amp;#x2F;&amp;#x2F; What is the name that js will use when it reaches for this?
  &amp;#x2F;&amp;#x2F; i.e. `global.nativeTest` in JS
  auto testModuleName = &amp;quot;nativeTest&amp;quot;;
  &amp;#x2F;&amp;#x2F; Create a JS object version of our binding
  auto object = jsi::Object::createFromHostObject(runtime, testBinding);
  &amp;#x2F;&amp;#x2F; set the &amp;quot;nativeTest&amp;quot; propert
  runtime.global().setProperty(runtime, testModuleName, std::move(object));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;part-2-installing-the-binding-on-android&quot;&gt;Part 2. Installing the binding (on Android)&lt;&#x2F;h3&gt;
&lt;p&gt;Since we have a reference to the runtime in Java land, we&#x27;ll have to create a JNI method to pass the runtime ptr to the native C++ land. We can add this JNI method to our TestBinding file with a guard.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;#if ANDROID
extern &amp;quot;C&amp;quot; {
JNIEXPORT void JNICALL Java_com_testmodule_MainActivity_install(
    JNIEnv *env, jobject thiz, jlong runtimePtr) {
  auto testBinding = std::make_shared&amp;lt;example::TestBinding&amp;gt;();
  jsi::Runtime *runtime = (jsi::Runtime *)runtimePtr;

  example::TestBinding::install(*runtime, testBinding);
}
}
#endif
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Then on the Java side (after we compile this into a shared library), we register this native function and call it when we&#x27;re ready.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;java&quot; class=&quot;language-java &quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&amp;#x2F;&amp;#x2F; In MainActivity

public class MainActivity extends ReactActivity implements ReactInstanceManager.ReactInstanceEventListener {
    static {
        &amp;#x2F;&amp;#x2F; Load our jni
        System.loadLibrary(&amp;quot;test_module_jni&amp;quot;);
    }

    &amp;#x2F;&amp;#x2F;... ellided ...

    @Override
    public void onReactContextInitialized(ReactContext context) {
        &amp;#x2F;&amp;#x2F; Call our native function with the runtime pointer
        install(context.getJavaScriptContextHolder().get());
    }

    &amp;#x2F;&amp;#x2F;  declare our native function
    public native void install(long jsContextNativePointer);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;part-3-calling-go&quot;&gt;Part 3. Calling Go&lt;&#x2F;h3&gt;
&lt;p&gt;Now that our binding is installed in the runtime, we can make it do something useful.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c++&quot; class=&quot;language-c++ &quot;&gt;&lt;code class=&quot;language-c++&quot; data-lang=&quot;c++&quot;&gt;jsi::Value TestBinding::get(jsi::Runtime &amp;amp;runtime,
                            const jsi::PropNameID &amp;amp;name) {
  auto methodName = name.utf8(runtime);

  if (methodName == &amp;quot;runTest&amp;quot;) {
    return jsi::Function::createFromHostFunction(
        runtime, name, 0,
        [](jsi::Runtime &amp;amp;runtime, const jsi::Value &amp;amp;thisValue,
           const jsi::Value *arguments,
           size_t count) -&amp;gt; jsi::Value { return TestNum(); });
  }
  return jsi::Value::undefined();
}

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we return a &lt;code&gt;jsi::Function&lt;&#x2F;code&gt; when JS calls &lt;code&gt;global.nativeTest.runTest&lt;&#x2F;code&gt;. When JS calls it (as in &lt;code&gt;global.nativeTest.runTest()&lt;&#x2F;code&gt;) we execute the code inside the closure, which just returns &lt;code&gt;TestNum()&lt;&#x2F;code&gt;. TestNum is a Go function that&#x27;s exported through cgo so that it is available to c&#x2F;c++. Our Go code looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;go&quot; class=&quot;language-go &quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;package main

import &amp;quot;C&amp;quot;

&amp;#x2F;&amp;#x2F; TestNum returns a test number to be used in JSI
&amp;#x2F;&amp;#x2F;export TestNum
func TestNum() int {
	return int(9001)
}
func main() {
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;cgo builds a header and creates a shared library that is used by our binding.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;building&quot;&gt;Building&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Look at the CMakeLists.txt for specifics on building the C++ code.&lt;&#x2F;li&gt;
&lt;li&gt;Look at from-go&#x2F;build.sh for specifics on building the go code.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;a-go-shared-library-for-c-java&quot;&gt;A Go Shared Library for C + Java&lt;&#x2F;h3&gt;
&lt;p&gt;It&#x27;s possible to build the Go code as a shared library for both C and Java, but you&#x27;ll have to define your own JNI methods. It would be nice if gomobile bind also generated C headers for android, but it doesn&#x27;t seem possible right now. Instead you&#x27;ll have to run &lt;code&gt;go build -buildmode=c-shared&lt;&#x2F;code&gt; directly and define your jni methods yourself. Take a look at &lt;code&gt;from-go&#x2F;build.sh&lt;&#x2F;code&gt; and testnum.go for specifics.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@christian.falch&#x2F;https-medium-com-christian-falch-react-native-jsi-challenge-1201a69c8fbf&quot;&gt;JSI Challenge #1&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;medium.com&#x2F;@christian.falch&#x2F;react-native-jsi-challenge-2-56fc4dd91613&quot;&gt;JSI Challenge #2&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;blog.nparashuram.com&#x2F;2019&#x2F;01&#x2F;react-natives-new-architecture-glossary.html&quot;&gt;RN Glossary of Terms&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.dogan.io&#x2F;2015&#x2F;08&#x2F;15&#x2F;java-jni-jnr-go&#x2F;&quot;&gt;GO JNI&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;rakyll.org&#x2F;cross-compilation&#x2F;&quot;&gt;GO Cross Compilation&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	
	<entry xml:lang="en">
		<title>An Intro to Functional Reactive Programming in UIs</title>
		<published>2014-11-16T00:00:00+00:00</published>
		<updated>2014-11-16T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/frp/" type="text/html"/>
		<id>https://marcopolo.io/code/frp/</id>
		<content type="html">&lt;p&gt;Maybe you&#x27;ve heard of &lt;a href=&quot;https:&#x2F;&#x2F;facebook.github.io&#x2F;react&#x2F;&quot;&gt;React&lt;&#x2F;a&gt;, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;swannodette&#x2F;om&quot;&gt;Om&lt;&#x2F;a&gt;,
or &lt;a href=&quot;http:&#x2F;&#x2F;elm-lang.org&#x2F;&quot;&gt;Elm&lt;&#x2F;a&gt;, and wondering: what&#x27;s the deal with
functional reactive programming (FRP)?&lt;&#x2F;p&gt;
&lt;p&gt;This post will act as primer on FRP using vanilla JS, but the ideas presented
here translate pretty easily in any language and UI system.&lt;&#x2F;p&gt;
&lt;p&gt;So let&#x27;s start with an informal, pragmatic definition of FRP:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Use streams of data to create the application state (data)&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;And&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Build a UI given only the application state with pure functions (view)&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;h2 id=&quot;streams-and-arrays&quot;&gt;Streams and arrays&lt;&#x2F;h2&gt;
&lt;p&gt;You can imagine streams of data as a set of values over time.&lt;&#x2F;p&gt;
&lt;p&gt;A stream of numbers representing a counter would look like:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[0,1,2,3,4,5,6,...]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each number is essentially a snapshot of the value at that time.&lt;&#x2F;p&gt;
&lt;p&gt;Streams are similar to arrays, but the main difference is time.
An immutable array has all the values it will ever have when it is created, while a stream represents all the values that have happened and will
happen.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s a concrete example: You are an owner of an exclusive restaurant.
It&#x27;s so exclusive that people have to make reservations months in advance.
Every night you have a list of people at your restaurant (because they&#x27;ve
already made reservations). Imagine the list being &lt;code&gt;[amy, sally, bob]&lt;&#x2F;code&gt;.
To count the number of guests, we would just reduce over the list
adding 1 for every guest. If we wanted to know how much each guest spent
we would map against a function that tells us the guest&#x27;s bill.&lt;&#x2F;p&gt;
&lt;p&gt;This is just a normal array with normal map&#x2F;reduce construct.
For completeness here&#x27;s the equivalent code.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;var guests = [&amp;quot;amy&amp;quot;, &amp;quot;sally&amp;quot;, &amp;quot;bob&amp;quot;];
var bills = { amy: 22.5, sally: 67.0, bob: 6.0 };

&amp;#x2F;&amp;#x2F; Count the guests
guests.reduce(function(sum, guest) {
  return sum + 1;
}, 0);
&amp;#x2F;&amp;#x2F; =&amp;gt; 3
&amp;#x2F;&amp;#x2F; Get the bills
guests.map(function(guest) {
  return bills[guest];
});
&amp;#x2F;&amp;#x2F; =&amp;gt; [22.5, 67, 6]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Unfortunately Sally had some bad fish and died after eating at your
restaurant, so everyone has cancelled their reservations and you are
now a fast food place. In this case you don&#x27;t have a list of guests,
instead you have a &lt;em&gt;stream&lt;&#x2F;em&gt; of people who come in and order food.
&lt;code&gt;Frank&lt;&#x2F;code&gt; might come in at 10 am, followed by &lt;code&gt;Jack&lt;&#x2F;code&gt; at 2 pm. To get
similar data as before we would again map&#x2F;reduce over the stream,
but since we are operating over a stream that never ends, the values
from map&#x2F;reduce themselves become streams that never end.&lt;&#x2F;p&gt;
&lt;p&gt;Here is some equivalent pseudo code for streams that calculates
the &lt;code&gt;guestCounts&lt;&#x2F;code&gt; and the &lt;code&gt;guestBills&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;guests      = [... time passes ..., Frank, ... time passes ..., Jack, ... ]

guestCounts = [... time passes ..., 1,     ... time passes ..., 2, ... ]
guestBills =  [... time passes ..., 5.50,  ... time passes ..., 6.50, ... ]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;So a stream is just like an array that never ends, and represents
snapshots of time.&lt;&#x2F;p&gt;
&lt;p&gt;Now that we have an intuitive idea what streams are, we can actually
implement them.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;streams-of-data&quot;&gt;Streams of data&lt;&#x2F;h2&gt;
&lt;p&gt;A stream of numbers representing a counter would look like:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[0,1,2,3,4,5,6,...]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If we wanted to keep track of how long someone was on our page,
we could just display the latest value of the counter stream
in our UI and that would be enough.&lt;&#x2F;p&gt;
&lt;p&gt;A more involved example: Imagine we had a stream of data
that represents the keys pressed on the keyboard.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;p&amp;quot;,&amp;quot;w&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;o&amp;quot;,&amp;quot;w&amp;quot;,&amp;quot;n&amp;quot;,...]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we want to have a stream that represents the state of the system,
say the amount of keys pressed.&lt;&#x2F;p&gt;
&lt;p&gt;Our key count stream would look like:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[&amp;quot;p&amp;quot;,&amp;quot;w&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;o&amp;quot;,&amp;quot;w&amp;quot;,&amp;quot;n&amp;quot;,...]
=&amp;gt;
[ 1,  2,  3,  4,  5,  6,  7, ...]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This transformation would happen with a reducing function.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;var keyCountReducer = function(reducedValue, streamSnapshot) {
  return reducedValue + 1;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This function takes in the stream value, and a reduced value so far, and
returns a new reduced value. In this case a simple increment.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve talked about streams for a while now, let&#x27;s implement them.&lt;&#x2F;p&gt;
&lt;p&gt;In the following code, we create a function that will return an object with two
methods: &lt;code&gt;observe&lt;&#x2F;code&gt; for registering event listeners and &lt;code&gt;update&lt;&#x2F;code&gt; for adding a value
to the stream.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F; A function to make streams for us
var streamMaker = function() {
  var registeredListeners = [];
  return {
    &amp;#x2F;&amp;#x2F; Have an observe function, so
    &amp;#x2F;&amp;#x2F; people who are interested can
    &amp;#x2F;&amp;#x2F; get notified when there is an update
    observe: function(callback) {
      registeredListeners.push(callback);
    },

    &amp;#x2F;&amp;#x2F; Add a value to this stream
    &amp;#x2F;&amp;#x2F; Once added, will notify all
    &amp;#x2F;&amp;#x2F; interested parties
    update: function(value) {
      registeredListeners.forEach(function(cb) {
        cb(value);
      });
    }
  };
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We also want to make a helper function that will create a new reduced stream
given an existing &lt;code&gt;stream&lt;&#x2F;code&gt;, a &lt;code&gt;reducingFunction&lt;&#x2F;code&gt;, and an &lt;code&gt;initialReducedValue&lt;&#x2F;code&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F; A function to make a new stream from an existing stream
&amp;#x2F;&amp;#x2F; a reducing function, and an initial reduced value
var reducedStream = function(stream, reducingFunction, initialReducedValue) {
  var newStream = streamMaker();
  var reducedValue = initialReducedValue;

  stream.observe(function(streamSnapshotValue) {
    reducedValue = reducingFunction(reducedValue, streamSnapshotValue);
    newStream.update(reducedValue);
  });
  return newStream;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now to implement the keypress stream and count stream.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F; Our reducer from before
var keyCountReducer = function(reducedValue, streamSnapshot) {
  return reducedValue + 1;
};

&amp;#x2F;&amp;#x2F; Create the keypress stream
var keypressStream = streamMaker();
&amp;#x2F;&amp;#x2F; an observer will have that side effect of printing out to the console
keypressStream.observe(function(v) {
  console.log(&amp;quot;key: &amp;quot;, v);
});

&amp;#x2F;&amp;#x2F; Whenever we press a key, we&amp;#x27;ll update the stream to be the char code.
document.onkeypress = function(e) {
  keypressStream.update(String.fromCharCode(e.charCode));
};

&amp;#x2F;&amp;#x2F; Using our reducedStream helper function we can make a new stream
&amp;#x2F;&amp;#x2F; That reduces the keypresses into a stream of key counts
var countStream = reducedStream(keypressStream, keyCountReducer, 0);
countStream.observe(function(v) {
  console.log(&amp;quot;Count: &amp;quot;, v);
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now with the new stream we can display it like we did before.&lt;&#x2F;p&gt;
&lt;p&gt;Which leads us into our next point...&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rendering-uis-given-data&quot;&gt;Rendering UIs given data&lt;&#x2F;h2&gt;
&lt;p&gt;Now that we have a system for generating state through streams,
let&#x27;s actually show something off.&lt;&#x2F;p&gt;
&lt;p&gt;This is where React.js shines, but for the purpose of this post we&#x27;ll
build our own system.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s say at one point in time our data looks like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;{&amp;quot;Count&amp;quot;:1}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And we want to render a UI that represents this information.
So we&#x27;ll write a simple piece of JS that renders html directly from the map.
To keep it easy, we&#x27;ll use the keys as div ids.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F;Pure Function to create the dom nodes
var createDOMNode = function(key, dataMapOrValue) {
  var div = document.createElement(&amp;quot;div&amp;quot;);
  div.setAttribute(&amp;quot;id&amp;quot;, key);

  &amp;#x2F;&amp;#x2F; Recurse for children
  if (typeof dataMapOrValue === &amp;quot;object&amp;quot; &amp;amp;&amp;amp; dataMapOrValue !== null) {
    Object.keys(dataMapOrValue).forEach(function(childKey) {
      var child = createDOMNode(childKey, dataMapOrValue[childKey]);
      div.appendChild(child);
    });
  } else {
    &amp;#x2F;&amp;#x2F; There are no children just a value.
    &amp;#x2F;&amp;#x2F; We set the data to be the content of the node
    &amp;#x2F;&amp;#x2F; Note this does not protect against XSS
    div.innerHTML = dataMapOrValue;
  }
  return div;
};

&amp;#x2F;&amp;#x2F; Render Data

var render = function(rootID, appState) {
  var root;
  &amp;#x2F;&amp;#x2F; Check if the root id is even defined
  if (document.getElementById(rootID) === null) {
    &amp;#x2F;&amp;#x2F; We need to add this root id so we can use it later
    root = document.createElement(&amp;quot;div&amp;quot;);
    root.setAttribute(&amp;quot;id&amp;quot;, rootID);
    document.body.appendChild(root);
  }

  root = document.getElementById(rootID);
  &amp;#x2F;&amp;#x2F; Clear all the existing content in the page
  root.innerHTML = &amp;quot;&amp;quot;;
  &amp;#x2F;&amp;#x2F; render the appState back in
  root.appendChild(createDOMNode(rootID, appState));
};

render(&amp;quot;counter&amp;quot;, { Count: 1 });
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;After running this code on a &lt;a href=&quot;about:blank&quot;&gt;blank page&lt;&#x2F;a&gt; we have a page
that says &lt;code&gt;1&lt;&#x2F;code&gt;, it worked!&lt;&#x2F;p&gt;
&lt;p&gt;A bit boring though, how about we make it a bit more interesting by updating
on the stream.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;rendering-streams-of-data&quot;&gt;Rendering Streams of data&lt;&#x2F;h2&gt;
&lt;p&gt;We&#x27;ve figured out how streams work, how to work with streams, and how to
render a page given some data. Now we&#x27;ll tie all the parts together; render
the stream as it changes over time.&lt;&#x2F;p&gt;
&lt;p&gt;It really is simple. All we have to do is re-render whenever we receive
a new value on the stream.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F; Let&amp;#x27;s observe the countstream and render when we get an update
countStream.observe(function(value) {
  render(&amp;quot;counter&amp;quot;, value);
});

&amp;#x2F;&amp;#x2F; And if we wanted to render what the keypress stream tells us, we can do so
&amp;#x2F;&amp;#x2F; just as easily
keypressStream.observe(function(value) {
  render(&amp;quot;keypress&amp;quot;, value);
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;single-app-state&quot;&gt;Single App State&lt;&#x2F;h2&gt;
&lt;p&gt;A single app state means that there is only one object that encapsulates the
state of your application.&lt;&#x2F;p&gt;
&lt;p&gt;Benefits:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;All changes to the frontend happen from this app state.&lt;&#x2F;li&gt;
&lt;li&gt;You can snapshot this state and be able to recreate the
frontend at any point in time (facilitates undo&#x2F;redo).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Downsides:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;You may conflate things that shouldn&#x27;t be together.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Having a single place that reflects the whole state is pretty amazing,
how often have you had your app get messed up because of some rogue event?
or hidden state affecting the application, or an ever growing state
scattered around the application.&lt;&#x2F;p&gt;
&lt;p&gt;No more.&lt;&#x2F;p&gt;
&lt;p&gt;A single app state is a natural end to the directed acyclic graph that
we&#x27;ve created with streams.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;stream1 -&amp;gt; mappedStream
                        \
                         mergedStream -&amp;gt; appStateStream
                        &amp;#x2F;
stream2 -&amp;gt; reducedStream
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;implementing-single-app-state&quot;&gt;Implementing Single App State&lt;&#x2F;h2&gt;
&lt;p&gt;In our previous example we had two pieces of state,
the counter and the keypress. We could merge these together into one stream, and
then form a single app state from that stream.&lt;&#x2F;p&gt;
&lt;p&gt;First let&#x27;s make a helper function that will merge streams for us. To keep it
general and simple we&#x27;ll take only two streams and a merging function.
It will return a new stream which is the merge of both streams with the mergeFn.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F; A merge streams helper function
var mergeStreams = function(streamA, streamB, mergeFn) {
  var streamData = [null, null];
  var newStream = streamMaker();

  streamA.observe(function(value) {
    streamData[0] = value;
    newStream.update(mergeFn.apply(null, streamData));
  });
  streamB.observe(function(value) {
    streamData[1] = value;
    newStream.update(mergeFn.apply(null, streamData));
  });

  return newStream;
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This implementation will call the merge function with the latest value from the
streams or null if the stream hasn&#x27;t emitted anything yet. This means the output
can return duplicate values of one of the streams.&lt;&#x2F;p&gt;
&lt;p&gt;(As a side note, the performance impact of duplicate values can be mitigated
with immutable datastructures)&lt;&#x2F;p&gt;
&lt;p&gt;We want to put both the keypress and the counter in one object, so our
merge function will do just that.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;var mergeIntoObject = function(keypress, counter) {
  return { counter: counter, keypress: keypress };
};
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now to create the single app state stream, and render that single app state.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;var appStateStream = mergeStreams(keypressStream, countStream, mergeIntoObject);

appStateStream.observe(function(value) {
  render(&amp;quot;app&amp;quot;, value);
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;final-code&quot;&gt;Final Code&lt;&#x2F;h2&gt;
&lt;p&gt;Most of these functions are library functions that you wouldn&#x27;t need to implement
yourself. The final application specific code would look like:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F; Create the keypress stream
var keypressStream = streamMaker();

&amp;#x2F;&amp;#x2F; Whenever we press a key, we&amp;#x27;ll update the stream to be the char code.
document.onkeypress = function(e) {
  keypressStream.update(String.fromCharCode(e.charCode));
};

var keyCountReducer = function(reducedValue, streamSnapshot) {
  return reducedValue + 1;
};
&amp;#x2F;&amp;#x2F; Using our reducedStream helper function we can make a new stream
&amp;#x2F;&amp;#x2F; That reduces the keypresses into a stream of key counts
var countStream = reducedStream(keypressStream, keyCountReducer, 0);

var mergeIntoObject = function(keypress, counter) {
  return { counter: counter, keypress: keypress };
};

var appStateStream = mergeStreams(keypressStream, countStream, mergeIntoObject);

appStateStream.observe(function(value) {
  render(&amp;quot;app&amp;quot;, value);
});
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can see a running version of this code &lt;a href=&quot;http:&#x2F;&#x2F;jsfiddle.net&#x2F;Ld3o1Lm5&#x2F;2&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;the-render-a-closer-look&quot;&gt;The render, a closer look&lt;&#x2F;h2&gt;
&lt;p&gt;So what does the render actually do?&lt;&#x2F;p&gt;
&lt;p&gt;Well, it clears the inner html of a containing div and adds an element inside of it.
But that&#x27;s pretty standard, how are we defining what element is created?
Why yes, it&#x27;s the createDOMNode function. In fact, if you wanted your data displayed
differently (e.g. in color, or upside down) all you&#x27;d have to do is write your own
createDOMNode function that adds the necessary styles or elements.&lt;&#x2F;p&gt;
&lt;p&gt;Essentially, the &lt;code&gt;createDOMNode&lt;&#x2F;code&gt; function controls what your UI will look like.
createDOMNode is a pure function, meaning for the same set of inputs, you&#x27;ll
always get the same set of outputs, and has no side effects (like an api call).
This wasn&#x27;t a happy accident, FRP leads to a
design where the functions which build your UI are pure functions!
This means UI components are significantly easier to reason about.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;time-travel&quot;&gt;Time travel&lt;&#x2F;h2&gt;
&lt;p&gt;Often when people talk about FRP, time travel is bound to get brought up.
Specifically the ability to undo and redo the state of your UI. Hopefully, if
you&#x27;ve gotten this far, you can see how trivial it would be to store the data
used to render the UIs in an array and just move forward and backward to
implement redo and undo.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;&#x2F;h2&gt;
&lt;p&gt;If you care about performance in the slightest, you probably shuddered when
I nuked the containing element and recreated all the children nodes. I don&#x27;t
blame you; however, that is an implementation detail. While my implementation
is slow, there are implementations (e.g. React) that only update the items and
attributes that have changed, thus reaping performance benefits with no cost
to the programmer! You are getting a better system for modeling UIs and
the performance boosts for free! Furthermore a lot of smart people are working
on React, and as it gets faster, so will your app. Without any effort on your
part.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;now-with-actual-libraries&quot;&gt;Now with actual libraries&lt;&#x2F;h2&gt;
&lt;p&gt;A lot of what we wrote was the library to get streams up and running,
however those already exists (e.g. &lt;a href=&quot;http:&#x2F;&#x2F;baconjs.github.io&#x2F;&quot;&gt;Bacon.js&lt;&#x2F;a&gt; and &lt;a href=&quot;https:&#x2F;&#x2F;facebook.github.io&#x2F;react&#x2F;&quot;&gt;React.js&lt;&#x2F;a&gt;)&lt;&#x2F;p&gt;
&lt;p&gt;A couple quick notes if this is your first time looking at React.js or Bacon.js.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;getInitialState&lt;&#x2F;code&gt; defines the initial local state of the component.
&lt;code&gt;componentWillMount&lt;&#x2F;code&gt; is a function that gets called before the component
is placed on the DOM.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;stream&amp;gt;.scan&lt;&#x2F;code&gt; is our reducing function in Bacon.js parlance.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;javascript&quot; class=&quot;language-javascript &quot;&gt;&lt;code class=&quot;language-javascript&quot; data-lang=&quot;javascript&quot;&gt;&amp;#x2F;&amp;#x2F; Our streams just like before
var keypressStream = Bacon.fromEventTarget(document.body, &amp;quot;keypress&amp;quot;).map(
  function(e) {
    return String.fromCharCode(e.charCode);
  }
);

var countStream = keypressStream.scan(0, function(count, key) {
  return count + 1;
});

var KeyPressComponent = React.createClass({
  getInitialState: function() {
    return { count: 0, keypress: &amp;quot;&amp;lt;press a key&amp;gt;&amp;quot;, totalWords: &amp;quot;&amp;quot; };
  },
  componentWillMount: function() {
    this.props.countStream.onValue(
      function(count) {
        this.setState({ count: count });
      }.bind(this)
    );

    this.props.keypressStream.onValue(
      function(key) {
        this.setState({ keypress: key });
      }.bind(this)
    );

    &amp;#x2F;&amp;#x2F; Add something extra because why not
    this.props.keypressStream
      .scan(&amp;quot;&amp;quot;, function(totalWords, key) {
        return totalWords + key;
      })
      .onValue(
        function(totalWords) {
          this.setState({ totalWords: totalWords });
        }.bind(this)
      );
  },
  render: function() {
    return React.DOM.div(
      null,
      React.createElement(&amp;quot;h1&amp;quot;, null, &amp;quot;Count: &amp;quot; + this.state.count),
      React.createElement(&amp;quot;h1&amp;quot;, null, &amp;quot;Keypress: &amp;quot; + this.state.keypress),
      React.createElement(&amp;quot;h1&amp;quot;, null, &amp;quot;Total words: &amp;quot; + this.state.totalWords)
    );
  }
});

React.render(
  React.createElement(KeyPressComponent, {
    keypressStream: keypressStream,
    countStream: countStream
  }),
  document.body
);
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;jsfiddle for this code &lt;a href=&quot;http:&#x2F;&#x2F;jsfiddle.net&#x2F;jf2j62wj&#x2F;10&#x2F;&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;closing-notes&quot;&gt;Closing Notes&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;facebook.github.io&#x2F;react&#x2F;&quot;&gt;React&lt;&#x2F;a&gt; is great for reactively rendering the ui.
&lt;a href=&quot;http:&#x2F;&#x2F;baconjs.github.io&#x2F;&quot;&gt;Bacon.js&lt;&#x2F;a&gt; is a great library that implements these streams.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re looking to really delve into FRP:
&lt;a href=&quot;http:&#x2F;&#x2F;elm-lang.org&#x2F;&quot;&gt;Elm&lt;&#x2F;a&gt; has a well thought out FRP system in a haskell like language.&lt;&#x2F;p&gt;
&lt;p&gt;If you&#x27;re feeling adventurous give Om &amp;amp; Clojurescript a shot.
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;swannodette&#x2F;om&quot;&gt;Om&lt;&#x2F;a&gt; is a great tool that adds immutability
to React, and brings React to Clojurescript&lt;&#x2F;p&gt;
&lt;p&gt;Finally, Evan Czaplicki (Elm creator) did a &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=Agu6jipKfYw&quot;&gt;great talk on FRP&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	
	<entry xml:lang="en">
		<title>Introducing Servant, a Clojurescript library for web workers</title>
		<published>2013-10-01T00:00:00+00:00</published>
		<updated>2013-10-01T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/servant-cljs/" type="text/html"/>
		<id>https://marcopolo.io/code/servant-cljs/</id>
		<content type="html">&lt;h1 id=&quot;concurrent-programming&quot;&gt;Concurrent Programming&lt;&#x2F;h1&gt;
&lt;p&gt;Javascript by default is single threaded, but web workers introduce
OS level threads. Concurrent programming is hard enough (in imperative
languages), so the webworker designers decided to circumvent a bunch of
concurrency problems by forbidding any shared data between threads. There are
better ways of doing this (read &lt;em&gt;immutability&lt;&#x2F;em&gt;), but we work with what we got.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;br&gt;&lt;&#x2F;br&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;problems-with-web-workers&quot;&gt;Problems with web workers&lt;&#x2F;h1&gt;
&lt;p&gt;I&#x27;ve done a couple projects with web workers. The biggest project being
&lt;a href=&quot;http:&#x2F;&#x2F;cryptic.io&quot;&gt;Cryptic.io&lt;&#x2F;a&gt;, which uses webworkers to efficiently
encrypt&#x2F;decrypt large (GBs) files, and parallel {down,up}load file chunks. Here
are problems I&#x27;ve stumbled across:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Everything about the web worker needs to be asynchronous, meaning callback hell&lt;&#x2F;li&gt;
&lt;li&gt;You need to think in a separate context for the web worker, you can&#x27;t call any functions defined with the rest of your code.&lt;&#x2F;li&gt;
&lt;li&gt;Distributing workload effectively.&lt;&#x2F;li&gt;
&lt;li&gt;The problems only gets worse the more web workers you bring in.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;br &#x2F;&gt;
&lt;h1 id=&quot;enter-servant&quot;&gt;Enter Servant&lt;&#x2F;h1&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;marcopolo&#x2F;servant&quot;&gt;Servant&lt;&#x2F;a&gt; is a super small (literally ~100 lines) library that solves all the
problems above, allowing you to write clean, multithreaded, ClojureScript. Even
though it&#x27;s small, it does a lot.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;It allows you to define servant functions alongside the rest of your code, even using functions already defined in your
namespace.&lt;&#x2F;li&gt;
&lt;li&gt;It automatically balances work across webworkers.&lt;&#x2F;li&gt;
&lt;li&gt;It provides simple ways to do a normal (copy of arguments) or efficient (arraybuffer transfer) call
to webworkers, easily.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;sharing-functions-and-predefined-variables&quot;&gt;Sharing functions, and predefined variables&lt;&#x2F;h1&gt;
&lt;p&gt;This was the trickiest part of the library. I wanted the ability to define
useful functions, and use them in the webworker without having to copy it over
to a separate worker.js file. I solved it by using the same exact file for both
the main page (browser context) and the web worker. That, however, came with one
problem; you have to explicitly declare code that should run on the webworker
and code that runs in the browser. Like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;clojure&quot; class=&quot;language-clojure &quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns servant.demo
  (:require [servant.core :as servant]
            [servant.worker :as worker]))

(defn window-load [] (.log js&amp;#x2F;console &amp;quot;this runs in the browser&amp;quot;))

(if (servant&amp;#x2F;webworker?)
    (worker&amp;#x2F;bootstrap) ;;Sets the worker up to receive messages
    (set! (.-onload js&amp;#x2F;window) window-load))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;As part of that caveat, the webworker can only see code that it can get to.
Anything defined in window-load would not be visible to the webworker. Now let&#x27;s
take a look at how we can define a servant function, using the &lt;code&gt;defservantfn&lt;&#x2F;code&gt;
macro.&lt;&#x2F;p&gt;
&lt;p&gt;We need to use a special function, &lt;code&gt;defservantfn&lt;&#x2F;code&gt; to define functions that will
serve as our &amp;quot;access points&amp;quot; to the web worker.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;clojure&quot; class=&quot;language-clojure &quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(ns servant.demo
  (:require-macros [servant.macros :refer [defservantfn]]))

(defn make-it-funny [not-funny]
  (str &amp;quot;Hahahah:&amp;quot; not-funny))

(defservantfn servant-with-humor [your-joke]
    (make-it-funny your-joke))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;defservantfn&lt;&#x2F;code&gt; macro simply calls a defn with the
same arguments, and registers that function with a hashmap atom for the
webworker. The key is the hash of the function and the value is the function
itself. The webworker needs to be able to know what function the browser is
referring in a message, so I use the function&#x27;s hash as a token that
the browser context and webworker can both agree on. The function&#x27;s
&lt;code&gt;.toString()&lt;&#x2F;code&gt; value could have worked just as well.&lt;&#x2F;p&gt;
&lt;p&gt;I should also mention, for efficiency reasons, Servant keeps a pool of N
webworkers (you specify N) alive (until you explicitly kill them) so you only
pay for the webworkers once. You control when the webworkers are created with
&lt;code&gt;servant&#x2F;spawn-servants&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;workload-balancing&quot;&gt;Workload Balancing&lt;&#x2F;h1&gt;
&lt;p&gt;Core.async is simply amazing, it took this tricky problem and made it trivial. The solution is 4 lines.
The solution for Servant is:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;spawn N number of workers and place them in a buffered (of size N) channel.&lt;&#x2F;li&gt;
&lt;li&gt;Take workers from the channel as you use them.&lt;&#x2F;li&gt;
&lt;li&gt;Put them back when you get your result.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;This is so beautifully simple. I just write the behavior I want, and core.async
handles the messy state. If all the webworkers are busy the code will &amp;quot;block&amp;quot;
until a webworker is free. What this means for you as a user, is you don&#x27;t have
to think about which worker is available to run your code.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;configurable-message-types&quot;&gt;Configurable message types&lt;&#x2F;h1&gt;
&lt;p&gt;Now the whole point of using webworkers is to be as fast as possible. Sometimes
you can&#x27;t even afford copying data to the webworker (especially if the data is
big, like at &lt;a href=&quot;http:&#x2F;&#x2F;cryptic.io&quot;&gt;Cryptic.io&lt;&#x2F;a&gt;). Servant provides a way to access
webworkers&#x27; nifty &lt;a href=&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;Guide&#x2F;Performance&#x2F;Using_web_workers#Passing_data_by_transferring_ownership_(transferable_objects)&quot;&gt;arraybuffer transfer context ability&lt;&#x2F;a&gt;.
Take for example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;clojure&quot; class=&quot;language-clojure &quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(defservantfn get-first-4bytes-as-str [arraybuffer]
  (let [d (js&amp;#x2F;DataView. arraybuffer)]
      (.toString (.getUint32 d 0) 16)))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;That function expects an arraybuffer and returns a string. If we wanted to be
efficient about it (and didn&#x27;t care about getting rid of the arraybuffer) we can
make the call using the &lt;code&gt;servant&#x2F;array-buffer-message-standard-reply&lt;&#x2F;code&gt; fn instead
of the &lt;code&gt;servant&#x2F;standard-message&lt;&#x2F;code&gt;. So the efficient result would be:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;clojure&quot; class=&quot;language-clojure &quot;&gt;&lt;code class=&quot;language-clojure&quot; data-lang=&quot;clojure&quot;&gt;(def arraybuffer (js&amp;#x2F;ArrayBuffer. 10))
(def d (js&amp;#x2F;DataView. arraybuffer))
(.setUint32 d 0 0xdeadbeef)
(def result-channel
  (servant&amp;#x2F;servant-thread
    servant-channel
    servant&amp;#x2F;array-buffer-message-standard-reply
    get-first-4bytes-as-str arraybuffer [arraybuffer]))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The arguments to servant-thread are:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;servant-channel&lt;&#x2F;code&gt; - channel that contains the available workers&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;servant&#x2F;array-buffer-message-standard-reply&lt;&#x2F;code&gt; - A function that defines how the &lt;code&gt;.postMessage&lt;&#x2F;code&gt; function will be called (a.k.a mesage-fn)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;get-first-4bytes-as-str&lt;&#x2F;code&gt; - The servant function we defined earlier&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;arraybuffer&lt;&#x2F;code&gt; - our argument to the function&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;[arraybuffer]&lt;&#x2F;code&gt; - a vector of arraybuffers that are going to be transferred&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The message-fn can be anything, but I think servant has you covered with:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;standard-message&lt;&#x2F;code&gt; : Copies all the data both ways&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;array-buffer-message&lt;&#x2F;code&gt; : &lt;em&gt;Can&lt;&#x2F;em&gt; transfer the context both ways&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;array-buffer-message-standard-reply&lt;&#x2F;code&gt; : &lt;em&gt;Can&lt;&#x2F;em&gt; transfer the context when making the call, &lt;em&gt;won&#x27;t&lt;&#x2F;em&gt; transfer the context coming back&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;There is a reason why array-buffer-message isn&#x27;t just the standard. You need to
explicitly tell the postMessage call that you want to transfer arraybuffers. So
to transfer context you need an additional argument, an array of arraybuffers.
You also need to make sure the defservantfn returns a vector of results and an
array of arraybuffers [result [arraybuffer1]] if you want to transfer the
arraybuffer from the worker to the browser context. I figured if you wanted
that you could use it and deal with the extra argument, if you didn&#x27;t you could
write your functions how you normally would.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;examples&quot;&gt;Examples&lt;&#x2F;h1&gt;
&lt;p&gt;I wrote two examples using the servant library:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;The first is a &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;servant-demo&quot;&gt;simple demo&lt;&#x2F;a&gt; showing several use cases.&lt;&#x2F;li&gt;
&lt;li&gt;The next is more featured demo that can encrypt&#x2F;decrypt large files efficiently using webworkers.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h1 id=&quot;last-thoughts&quot;&gt;Last thoughts&lt;&#x2F;h1&gt;
&lt;p&gt;I used to curse the name webworkers. They brought gifts of speed at the cost of
complexity. Servant is different, it doesn&#x27;t sacrifice simplicity or
efficiency. I&#x27;m pretty excited at the ease of using webworkers with servant, and
I hope you have fun making an amazing, multithreaded Clojurescript application!&lt;&#x2F;p&gt;
&lt;br &#x2F;&gt;
</content>
	</entry>
</feed>
