<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>MarcoPolo – Partially Functional - Rust</title>
	<author><name>Marco</name></author>
	<link href="https://marcopolo.io/tags/rust/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://marcopolo.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2019-12-12T00:00:00+00:00</updated>
	<id>https://marcopolo.io/tags/rust/atom.xml</id>
	
	<entry xml:lang="en">
		<title>From C to Rust to C again. Or: Re-exporting C exports in Rust</title>
		<published>2019-12-12T00:00:00+00:00</published>
		<updated>2019-12-12T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/from-c-to-rust-to-c/" type="text/html"/>
		<id>https://marcopolo.io/code/from-c-to-rust-to-c/</id>
		<content type="html">&lt;p&gt;The only difference between being a grown up and being a kid, in my experience, is as a grown up, you have much fewer people who are willing to play the game &lt;em&gt;telephone&lt;&#x2F;em&gt; with you. Luckily for me, I have access to a computer, a C compiler, and a Rust compiler. Let me show you how I played telephone with Rust &amp;amp; C.&lt;&#x2F;p&gt;
&lt;p&gt;tl;dr:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Rust can&#x27;t re-export from a linked C library (unless you rename) when compiled as a cdylib.&lt;&#x2F;li&gt;
&lt;li&gt;Look at this &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;2771&quot;&gt;issue&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Imagine you have some C code that provides &lt;code&gt;add_two&lt;&#x2F;code&gt;. It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int add_two(int n)
{
    return n + 2;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And you can even let Cargo deal with building your C library by making a build.rs with &lt;code&gt;cc&lt;&#x2F;code&gt;. Like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use cc;

fn main() {
    cc::Build::new().file(&amp;quot;src&amp;#x2F;c&amp;#x2F;foo.c&amp;quot;).compile(&amp;quot;foo&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now you want to be able to call &lt;code&gt;add_two&lt;&#x2F;code&gt; from Rust. Easy! You look at the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;ffi.html&quot;&gt;FFI&lt;&#x2F;a&gt; section in the Nomicon. And follow it like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[link(name = &amp;quot;foo&amp;quot;, kind = &amp;quot;static&amp;quot;)]
#[no_mangle]
extern &amp;quot;C&amp;quot; {
    pub fn add_two(x: u32) -&amp;gt; u32;
}

#[no_mangle]
pub extern &amp;quot;C&amp;quot; fn add_one(x: u32) -&amp;gt; u32 {
    let a = unsafe { add_two(x) };
    a - 1
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn it_works() {
        assert_eq!(add_one(2), 3);
        assert_eq!(unsafe { add_two(2) }, 4);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now for the last chain in our telephone. We&#x27;ll make a new C file that will call our Rust defined &lt;code&gt;add_one&lt;&#x2F;code&gt; and our C defined &lt;code&gt;add_two&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;extern int add_one(int n);
extern int add_two(int n);

int main()
{
    return add_one(add_two(39));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use Clang to build this file:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;clang call_rust.c -lrust_c_playground -L.&amp;#x2F;target&amp;#x2F;debug -o call_rust
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have an executable called &lt;code&gt;call_rust&lt;&#x2F;code&gt; which calls a Rust defined function and calls a C defined function that it pulled in from a single Rust Library (called &lt;code&gt;librust_c_playground.dylib&lt;&#x2F;code&gt; on macOS). The flags in the clang command mean: &lt;code&gt;-l&lt;&#x2F;code&gt; link this library; &lt;code&gt;-L&lt;&#x2F;code&gt; look here for the library.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve built the code, now we can even run it!&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;.&amp;#x2F;call_rust
echo $? # Print the return code of our program, hopefully 42
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Great! We&#x27;ve called C from a Rust Library from a C program. But there&#x27;s a catch. This won&#x27;t work if you are building a &lt;code&gt;cdylib&lt;&#x2F;code&gt;. There isn&#x27;t an RFC yet on how to re-export C externs. In the mean time you&#x27;ll either have to: re-export under a different name, or build a &lt;code&gt;dylib&lt;&#x2F;code&gt;. See this issue: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;2771&quot;&gt;Re-exporting C symbols for cdylib&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Hope this helps.&lt;&#x2F;p&gt;
</content>
	</entry>
	
	<entry xml:lang="en">
		<title>Wasm is the future of serverless. Terrafirma, serverless wasm functions.</title>
		<published>2019-11-06T00:00:00+00:00</published>
		<updated>2019-11-06T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/terrafirma/" type="text/html"/>
		<id>https://marcopolo.io/code/terrafirma/</id>
		<content type="html">&lt;p&gt;When I ran into Fastly&#x27;s &lt;a href=&quot;https:&#x2F;&#x2F;wasm.fastlylabs.com&#x2F;&quot;&gt;Terrarium&lt;&#x2F;a&gt;, the appeal of Webassembly (wasm) finally clicked for me. We could have lightweight sandboxes and bring in my own language and libraries without the overhead of a full OS VM or &lt;a href=&quot;https:&#x2F;&#x2F;blog.iron.io&#x2F;the-overhead-of-docker-run&#x2F;&quot;&gt;Docker&lt;&#x2F;a&gt;. That&#x27;s great for the serverless provider, but it&#x27;s also great for the end user. Less overhead means faster startup time and less total cost.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;how-much-faster&quot;&gt;How much faster?&lt;&#x2F;h2&gt;
&lt;p&gt;On my machine™, a hello world shell script takes 3ms, a docker equivalent takes 700ms, and a wasm equivalent takes 15ms.&lt;&#x2F;p&gt;
&lt;p&gt;Following &lt;a href=&quot;https:&#x2F;&#x2F;blog.iron.io&#x2F;the-overhead-of-docker-run&#x2F;&quot;&gt;this experiment&lt;&#x2F;a&gt; I get these results:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Running: .&amp;#x2F;hello.sh
avg: 3.516431ms
Running: docker run treeder&amp;#x2F;hello:sh
avg: 692.306769ms
Running: docker run --rm treeder&amp;#x2F;hello:sh
avg: 725.912422ms
Running: docker start -a reuse
avg: 655.059021ms
Running: node hello.js
avg: 79.233337ms
Running: wasmer run wasi-hello-world.wasm
avg: 15.155896ms
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;When I think about how WASM, Docker, and OS VMs (compute instances) play together, I picture this graph below.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;code&#x2F;wasm-graph.png&quot; alt=&quot;Safety versus overhead – Raw binary is fast unsafe; was is fast and safe; docker is safe.&quot; title=&quot;Safety vs Overhead&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The trend is that if you want safety and isolation, you must pay for it with overhead. WASM&#x27;s exception to that rule is what I think makes it so promising and interesting. Wasm provides the fastest way to run arbitrary user code in a sandboxed environment.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-is-webassembly&quot;&gt;What is Webassembly?&lt;&#x2F;h2&gt;
&lt;p&gt;Webassembly is a spec for a lightweight and sandboxed VM. Webassembly is run by a host, and can&#x27;t do any side effects, unless it calls a function provided by the host. For example, if your WASM code wanted to make a GET request to a website, it could only do that by asking the host to help. The host exposes these helper function to the WASM guest. In Terrafirma, these are the &lt;code&gt;hostcall_*&lt;&#x2F;code&gt; functions in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;go-wasm-terrafirma&#x2F;blob&#x2F;master&#x2F;imports.go&quot;&gt;&lt;code&gt;imports.go&lt;&#x2F;code&gt;&lt;&#x2F;a&gt;. It&#x27;s called &lt;code&gt;imports.go&lt;&#x2F;code&gt; because it is what your WASM code is importing from the host.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bring-your-own-tools&quot;&gt;Bring your own tools&lt;&#x2F;h2&gt;
&lt;p&gt;As long as you can compile everything to a .wasm file, you can use whatever tools and language you want. All I have to do is provide a runtime, and all you have to do is provide a wasm file. However, there is a subtle caveat here. The only way you can run side effects is with the host cooperation. So you (or some library you use) must understand the environment you&#x27;re running in in order to do anything interesting.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;what-about-a-standard-wasm-environment&quot;&gt;What about a standard WASM Environment?&lt;&#x2F;h2&gt;
&lt;p&gt;There isn&#x27;t a mature industry standard for what imports a host should provide to the WASM code running outside the browser. The closest thing we have is &lt;a href=&quot;https:&#x2F;&#x2F;wasi.dev&#x2F;&quot;&gt;WASI&lt;&#x2F;a&gt;, which defines a POSIX inspired set of syscalls that a host should implement. It&#x27;s useful because it allows code would otherwise require a real syscall to work in a WASM environment. For example, In Rust you can build with the &lt;code&gt;--target wasm32-wasi&lt;&#x2F;code&gt; flag and your code will just work in any &lt;a href=&quot;https:&#x2F;&#x2F;wasmer.io&#x2F;&quot;&gt;wasi environment&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;terrafirma&quot;&gt;Terrafirma&lt;&#x2F;h2&gt;
&lt;p&gt;Phew! Finally at TerraFirma. TerraFirma is a WASM runtime environment I wrote to let you run wasm code in the cloud. You upload your wasm file by copying it into a shared &lt;a href=&quot;https:&#x2F;&#x2F;keybase.io&#x2F;docs&#x2F;kbfs&quot;&gt;KBFS folder&lt;&#x2F;a&gt; with the keybase user &lt;a href=&quot;https:&#x2F;&#x2F;keybase.io&#x2F;kbwasm&quot;&gt;kbwasm&lt;&#x2F;a&gt;. Then you setup some DNS records to point your domain to TerraFirma&#x27;s servers. And that&#x27;s it! You can update the wasm code at any time by overwriting the old .wasm file with the new one.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;code-examples&quot;&gt;Code Examples&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;terrafirma-hello-world&quot;&gt;Hello World&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;terrafirma-scraper&quot;&gt;Scraper Endpoint&lt;&#x2F;a&gt; – A web scraper that uses Servo – a new browser engine from Mozilla.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;terrafirma-hello-world-tutorial&quot;&gt;Terrafirma – Hello World Tutorial&lt;&#x2F;h3&gt;
&lt;p&gt;This example uses Rust, so if you don&#x27;t have that setup &lt;a href=&quot;https:&#x2F;&#x2F;rustup.rs&#x2F;&quot;&gt;go here first&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Point your domain to TerraFirma servers (&lt;code&gt;terrafirma.marcopolo.io&lt;&#x2F;code&gt; or &lt;code&gt;52.53.126.109&lt;&#x2F;code&gt;) with an A record, and set a &lt;code&gt;TXT&lt;&#x2F;code&gt; record to point to your shared folder (e.g. &lt;code&gt;&amp;quot;kbp=&#x2F;keybase&#x2F;private&#x2F;&amp;lt;my_keybase_username&amp;gt;,kbwasm&#x2F;&amp;quot;&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;
example.com 300 A terrafirma.marcopolo.io

_keybase_pages.example.com 300 TXT &amp;quot;kbp=&amp;#x2F;keybase&amp;#x2F;private&amp;#x2F;&amp;lt;my_keybase_username&amp;gt;,kbwasm&amp;#x2F;&amp;quot;

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Verify the DNS records are correct&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;
$ dig example.com A
...
;; ANSWER SECTION:
wasm.marcopolo.io.      300     IN      A       52.53.126.109
...

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;br&#x2F;&gt;
&lt;pre&gt;&lt;code&gt;
$ dig _keybase_pages.example.com TXT
...
;; ANSWER SECTION:
_keybase_pages.example.com &amp;lt;number&amp;gt; IN TXT &amp;quot;kbp=&amp;#x2F;keybase&amp;#x2F;private&amp;#x2F;&amp;lt;my_keybase_username&amp;gt;,kbpbot&amp;#x2F;&amp;quot;
...

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;Clone the Hello World Repo&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;git clone git@github.com:MarcoPolo&amp;#x2F;terrafirma-hello-world.git
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Build it&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;cd terrafirma-hello-world
cargo build --release
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;Deploy it&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;
cp target&amp;#x2F;wasm32-unknown-unknown&amp;#x2F;release&amp;#x2F;terrafirma_helloworld.wasm &amp;#x2F;keybase&amp;#x2F;private&amp;#x2F;&amp;lt;your_kb_username&amp;gt;,kbwasm&amp;#x2F;hello.wasm

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Test it&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;pre&gt;&lt;code&gt;curl https:&amp;#x2F;&amp;#x2F;example.com&amp;#x2F;hello.wasm
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	
	<entry xml:lang="en">
		<title>Active Projects</title>
		<published>2019-08-30T00:00:00+00:00</published>
		<updated>2019-08-30T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/life/active-projects/" type="text/html"/>
		<id>https://marcopolo.io/life/active-projects/</id>
		<content type="html">&lt;h1 id=&quot;active-projects-with-updates&quot;&gt;Active Projects (with updates)&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;react-causal-profiler&quot;&gt;React Causal Profiler&lt;&#x2F;h2&gt;
&lt;p&gt;https:&#x2F;&#x2F;www.youtube.com&#x2F;watch?v=r-TLSBdHe1A&amp;amp;t=11s&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;fastly-labs-terrarium-on-kbfs&quot;&gt;fastly labs terrarium on KBFS&lt;&#x2F;h2&gt;
&lt;p&gt;Push wasm code, have it run on distributed servers for you
(done)[https:&#x2F;&#x2F;marcopolo.io&#x2F;wasm]&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;android-wired-a-rust-ui-framework-for-android&quot;&gt;Android Wired - A Rust UI framework for Android&lt;&#x2F;h2&gt;
&lt;p&gt;(repo)[https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;android-wired&#x2F;]&lt;&#x2F;p&gt;
&lt;p&gt;An attempt at building a friend Rust UI library for Android.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Coming up: Add flex-box support on android&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h1 id=&quot;interesting-cities-map&quot;&gt;Interesting Cities Map&lt;&#x2F;h1&gt;
&lt;p&gt;Yet another map of cities that seem nice to live in. Scored by:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Climbing&lt;&#x2F;li&gt;
&lt;li&gt;Bike Score&lt;&#x2F;li&gt;
&lt;li&gt;Walk Score&lt;&#x2F;li&gt;
&lt;li&gt;Population&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;To add:
&lt;a href=&quot;https:&#x2F;&#x2F;www.expatistan.com&#x2F;cost-of-living&#x2F;index&quot;&gt;Cost of living index&lt;&#x2F;a&gt;
Disaster preparedness&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;slack-bridge&quot;&gt;Slack Bridge&lt;&#x2F;h2&gt;
&lt;p&gt;Connect kb to slack with the bot library&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;slack-keybase-bridge&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;move-off-of-betterment&quot;&gt;Move off of betterment&lt;&#x2F;h2&gt;
&lt;p&gt;A 3% return is only barely better than a bank.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;rusty-keybase-bot&quot;&gt;Rusty Keybase Bot&lt;&#x2F;h2&gt;
&lt;p&gt;Build a Keybase Bot Library in Rust (With proper typings)&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;This is live! https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;keybase-bot-api&lt;&#x2F;li&gt;
&lt;li&gt;I rabbit holed into creating an AVDL parser with pest.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;riding-those-new-bart-trains&quot;&gt;Riding those new BART trains?&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Is it possible to figure out when the new bart trains are arriving so I can optimize my commute to ride those puppies?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;programmatically-find-climbing-crags&quot;&gt;Programmatically find Climbing crags&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;How can I parse USGS and GIS data to find good crags for climbing?&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	
	<entry xml:lang="en">
		<title>I moved my blog over to Zola, you should too</title>
		<published>2019-08-22T00:00:00+00:00</published>
		<updated>2019-08-22T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/migrating-to-zola/" type="text/html"/>
		<id>https://marcopolo.io/code/migrating-to-zola/</id>
		<content type="html">&lt;h1 id=&quot;blogging&quot;&gt;Blogging&lt;&#x2F;h1&gt;
&lt;p&gt;I started this blog like many other folks, on GitHub Pages. It was great at
the time. You can have a source repo that compiles to a blog. Neat! Over time
though I started really feeling the pain points with it. When I wanted to
write a quick post about something I&#x27;d often spend hours just trying to get
the right Ruby environment set up so I can see my blog locally. When I got an
email from GitHub saying that my blog repo has a security vulnerability in
one of its Gems, I took the opportunity to switch over to
&lt;a href=&quot;https:&#x2F;&#x2F;www.getzola.org&quot;&gt;Zola&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;zola&quot;&gt;Zola&lt;&#x2F;h1&gt;
&lt;p&gt;Zola make more sense to me than Jekyll. I think about my posts in a
hierarchy. I&#x27;d like my source code to match my mental representation. If you
look at the &lt;a href=&quot;https:&#x2F;&#x2F;marcopolo.io&#x2F;code&#x2F;migrating-to-zola&#x2F;&quot;&gt;source&lt;&#x2F;a&gt; of this blog, you&#x27;ll see I have 3 folders (code, books,
life). In each folder there are relevant posts. I wanted my blog to show the
contents folder as different sections. For the life of me I couldn&#x27;t figure
out how to do that in Jekyll. I ended up just using a single folder for all
my posts and using the category metadata in the front-matter to create the
different sections. With Zola, this kind of just worked. I had to create an
&lt;code&gt;_index.md&lt;&#x2F;code&gt; file to provide some metadata, but nothing overly verbose.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;i-m-not-a-jekyll-pro&quot;&gt;I&#x27;m not a Jekyll pro...&lt;&#x2F;h1&gt;
&lt;p&gt;Or even really any level past beginner. I image if you&#x27;ve already heavily
invested yourself in the Jekyll ecosystem this probably wouldn&#x27;t make sense
for you. I&#x27;m sure there are all sorts of tricks and features that Jekyll
can do that Zola cannot. I&#x27;m Okay with that. I really don&#x27;t need that much
from my blogging library.&lt;&#x2F;p&gt;
&lt;p&gt;Zola has 3 commands: &lt;code&gt;build&lt;&#x2F;code&gt;, &lt;code&gt;serve&lt;&#x2F;code&gt;, and &lt;code&gt;init&lt;&#x2F;code&gt;. They do what you&#x27;d expect
and nothing more. I really admire this philosophy. Whittle down your feature
set and make those features a &lt;em&gt;joy&lt;&#x2F;em&gt; to use.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;fast&quot;&gt;Fast&lt;&#x2F;h1&gt;
&lt;p&gt;Changes in Zola propagate quickly. Zola rebuilds my (admittedly very small blog) in less than a millisecond. Zola comes with a livereload script that automatically updates your browser when you are in &lt;code&gt;serve&lt;&#x2F;code&gt; mode. It&#x27;s feasible to write your post and see how it renders almost instantly.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;transition&quot;&gt;Transition&lt;&#x2F;h1&gt;
&lt;p&gt;The biggest change was converting Jekyll&#x27;s front-matter (the stuff at the top
of the md files) format into Zola&#x27;s front-matter format. Which was changing
this:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;---
layout: post
title: Interacting with Go from React Native through JSI
categories: javascript react-native jsi go
---

&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;into this:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;+++
title = &amp;quot;Interacting with Go from React Native through JSI&amp;quot;
[taxonomies]
tags = [&amp;quot;javascript&amp;quot;, &amp;quot;react-native&amp;quot;, &amp;quot;JSI&amp;quot;, &amp;quot;Go&amp;quot;]
+++
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;There was also a slight rewrite in the template files that was necessary
since Zola uses the &lt;a href=&quot;https:&#x2F;&#x2F;tera.netlify.com&quot;&gt;Tera Templating Engine&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The rest was just moving (I&#x27;d argue organizing) files around.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;prettier-repo&quot;&gt;Prettier Repo&lt;&#x2F;h1&gt;
&lt;p&gt;I think at the end the repo became a little prettier to look at. You could
argue it&#x27;s a small thing, but I think these small things matter. It&#x27;s already
hard enough to sit down and write a post. I want every bit of the experience
to be beautiful.&lt;&#x2F;p&gt;
&lt;p&gt;But don&#x27;t take my word for it! judge yourself: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;marcopolo.github.io&#x2F;tree&#x2F;jekyll_archive&quot;&gt;Jekyll&lt;&#x2F;a&gt; vs. &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;MarcoPolo&#x2F;marcopolo.github.io&quot;&gt;Zola&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
