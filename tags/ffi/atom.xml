<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>MarcoPolo â€“ Partially Functional - FFI</title>
	<author><name>Marco</name></author>
	<link href="https://marcopolo.io/tags/ffi/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://marcopolo.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2019-12-12T00:00:00+00:00</updated>
	<id>https://marcopolo.io/tags/ffi/atom.xml</id>
	
	<entry xml:lang="en">
		<title>From C to Rust to C again. Or: Re-exporting C exports in Rust</title>
		<published>2019-12-12T00:00:00+00:00</published>
		<updated>2019-12-12T00:00:00+00:00</updated>
		<link href="https://marcopolo.io/code/from-c-to-rust-to-c/" type="text/html"/>
		<id>https://marcopolo.io/code/from-c-to-rust-to-c/</id>
		<content type="html">&lt;p&gt;The only difference between being a grown up and being a kid, in my experience, is as a grown up, you have much fewer people who are willing to play the game &lt;em&gt;telephone&lt;&#x2F;em&gt; with you. Luckily for me, I have access to a computer, a C compiler, and a Rust compiler. Let me show you how I played telephone with Rust &amp;amp; C.&lt;&#x2F;p&gt;
&lt;p&gt;tl;dr:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Rust can&#x27;t re-export from a linked C library (unless you rename) when compiled as a cdylib.&lt;&#x2F;li&gt;
&lt;li&gt;Look at this &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;2771&quot;&gt;issue&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Imagine you have some C code that provides &lt;code&gt;add_two&lt;&#x2F;code&gt;. It looks like this:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;int add_two(int n)
{
    return n + 2;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;And you can even let Cargo deal with building your C library by making a build.rs with &lt;code&gt;cc&lt;&#x2F;code&gt;. Like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;use cc;

fn main() {
    cc::Build::new().file(&amp;quot;src&amp;#x2F;c&amp;#x2F;foo.c&amp;quot;).compile(&amp;quot;foo&amp;quot;);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now you want to be able to call &lt;code&gt;add_two&lt;&#x2F;code&gt; from Rust. Easy! You look at the &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;ffi.html&quot;&gt;FFI&lt;&#x2F;a&gt; section in the Nomicon. And follow it like so:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;#[link(name = &amp;quot;foo&amp;quot;, kind = &amp;quot;static&amp;quot;)]
#[no_mangle]
extern &amp;quot;C&amp;quot; {
    pub fn add_two(x: u32) -&amp;gt; u32;
}

#[no_mangle]
pub extern &amp;quot;C&amp;quot; fn add_one(x: u32) -&amp;gt; u32 {
    let a = unsafe { add_two(x) };
    a - 1
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn it_works() {
        assert_eq!(add_one(2), 3);
        assert_eq!(unsafe { add_two(2) }, 4);
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now for the last chain in our telephone. We&#x27;ll make a new C file that will call our Rust defined &lt;code&gt;add_one&lt;&#x2F;code&gt; and our C defined &lt;code&gt;add_two&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;c&quot; class=&quot;language-c &quot;&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;extern int add_one(int n);
extern int add_two(int n);

int main()
{
    return add_one(add_two(39));
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We use Clang to build this file:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;clang call_rust.c -lrust_c_playground -L.&amp;#x2F;target&amp;#x2F;debug -o call_rust
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we have an executable called &lt;code&gt;call_rust&lt;&#x2F;code&gt; which calls a Rust defined function and calls a C defined function that it pulled in from a single Rust Library (called &lt;code&gt;librust_c_playground.dylib&lt;&#x2F;code&gt; on macOS). The flags in the clang command mean: &lt;code&gt;-l&lt;&#x2F;code&gt; link this library; &lt;code&gt;-L&lt;&#x2F;code&gt; look here for the library.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ve built the code, now we can even run it!&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;.&amp;#x2F;call_rust
echo $? # Print the return code of our program, hopefully 42
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Great! We&#x27;ve called C from a Rust Library from a C program. But there&#x27;s a catch. This won&#x27;t work if you are building a &lt;code&gt;cdylib&lt;&#x2F;code&gt;. There isn&#x27;t an RFC yet on how to re-export C externs. In the mean time you&#x27;ll either have to: re-export under a different name, or build a &lt;code&gt;dylib&lt;&#x2F;code&gt;. See this issue: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-lang&#x2F;rfcs&#x2F;issues&#x2F;2771&quot;&gt;Re-exporting C symbols for cdylib&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Hope this helps.&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
